using System;
using System.Collections.Generic;
using System.Linq;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Declarations;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Members;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Types;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Types.Abstract;
using Vostok.Hercules.Serializer.Generator.Core.Primitives;
using Vostok.Hercules.Serializer.Generator.Extensions;

namespace Vostok.Hercules.Serializer.Generator.Core.Writer.Extensions;

public static class CodeWriterWriteExtensions
{
    private static (string, string) Brackets => ("{\n", "}\n");
    private static (string, string) Parentheses => ("(", ")");

    public static CodeWriter WriteMethods(this CodeWriter writer, IEnumerable<MethodBuilder> methods) =>
        writer.WriteJoin(
            methods
                .OrderByDescending(m => m.Accessibility)
                .ThenBy(m => m.IsStatic ? 0 : 1)
                .ThenBy(m => m.Name), "\n",
            static (method, w) => w.WriteMethod(method)
        );

    public static CodeWriter WriteMethod(this CodeWriter writer, MethodBuilder method) =>
        writer
            .AppendAccessibility(method.Accessibility).Append(" ")
            .When(method.IsStatic, static w => w.Append("static "))
            .When(method.IsOverride, static w => w.Append("override "))
            .When(method.IsNew, static w => w.Append("new "))
            .AppendType(method.ReturnType ?? TypeDescriptor.Void).Append(" ")
            .Append(method.Name)
            .WriteGenericArgs(method.Generics)
            .WriteParameters(method.Parameters)
            .WriteConstraints(method.Generics)
            .WhenNotNull(method.EmitBody,
                then: static (emitBody, w) => w.AppendLine().WriteCodeBlock(emitBody),
                @else: static w => w.Append(";\n")
            );

    public static CodeWriter WriteParameters(this CodeWriter writer, IEnumerable<ParameterBuilder> parameters) =>
        writer
            .WriteBlock(Parentheses, parameters, static (parameters, w) => w
                .WriteJoin(parameters, ",\n", static (p, pw) => pw.AppendParameter(p))
            );

    public static CodeWriter WriteProperties(this CodeWriter writer, IEnumerable<PropertyBuilder> properties) =>
        writer.WriteJoin(properties, null, static (property, w) => w.WriteProperty(property).AppendLine());

    public static CodeWriter WriteConstructor(this CodeWriter writer, ConstructorBuilder ctorBuilder) =>
        writer
            .AppendAccessibility(ctorBuilder.Accessibility).Append(" ")
            .AppendType(ctorBuilder.DeclaringTypeName)
            .WriteParameters(ctorBuilder.Parameters)
            .WriteJoin(ctorBuilder.BaseCtorArgs, ", ",
                writeEntry: static (arg, w) => w.Append(arg.Key).Append(": ").Append(arg.Value),
                prepend: static w => w.Append(" : base("),
                append: static w => w.Append(")")
            )
            .AppendLine()
            .WhenNotNull(ctorBuilder.EmitBody,
                then: static (emit, w) => w.WriteCodeBlock(emit),
                @else: static w => w.AppendLine()
            );

    public static CodeWriter WriteProperty(this CodeWriter writer, PropertyBuilder property) =>
        writer
            .AppendAccessibility(property.Accessibility).Append(" ")
            .When(property is { Kind: ParameterKind.Field, ReadOnly: true }, static w => w.Append("readonly "))
            .AppendType(property.Type).Append(" ")
            .Append(property.Name)
            .When(property is { Kind: ParameterKind.Property, ReadOnly: true }, static w => w.Append(" { get; }"))
            .When(property is { Kind: ParameterKind.Property, ReadOnly: false }, static w => w.Append(" { get; set; }"))
            .When(property.Kind == ParameterKind.Field, static w => w.Append(";"));

    public static CodeWriter WriteType(this CodeWriter writer, ITypeBuilder builder) =>
        writer
            .WriteJoin(builder.Usings, null, static (u, w) => w.Append("using ").Append(u).Append(";"))
            .AppendNamespace(builder.Namespace)
            .AppendLine()
            .WriteCodeBlock(builder, static (builder, nw) => nw
                .WriteAttributes(builder.Attributes)
                .WriteCommentLine("<auto-generated>")
                .AppendAccessibility(builder.Accessibility).Append(" ")
                .Append(GetTypeKind(builder)).Append(" ")
                .Append(builder.Name)
                .WhenOfType<EnumBuilder>(builder, static (e, ew) => ew
                    .WriteBaseTypes([e.BaseType]).AppendLine()
                    .WriteCodeBlock(e.Values, static (values, bw) => bw.WriteJoin(values, null, static (entry, vw) => vw
                        .Append(entry.Key).Append(" = ").Append(entry.Value.ToString()).AppendLine(",")
                    )))
                .WhenOfType<StatefulTypeBuilder>(builder, static (s, w) => w
                    .WriteGenericArgs(s.Generics).Append(" ")
                    .WriteBaseTypes(s.Interfaces.PrependIfNotNull(s is ClassBuilder cb ? cb.BaseType : null))
                    .WriteConstraints(s.Generics)
                    .AppendLine()
                    .WriteCodeBlock(s, static (s, tw) => tw
                        .WriteProperties(s.Properties.Where(p => p.Kind == ParameterKind.Field))
                        .WhenOfType<IInitializabeTypeBuilder>(s, static (i, iw) => iw
                            .WriteJoin(i.Constructors, "\n\n", (ctor, cw) => cw.WriteConstructor(ctor))
                            .AppendLine()
                        )
                        .WriteProperties(s.Properties.Where(p => p.Kind == ParameterKind.Property))
                        .WriteMethods(s.Methods)
                    )
                )
            );

    public static CodeWriter WriteAttributes(this CodeWriter writer, IEnumerable<string> attributes) =>
        writer.WriteJoin(attributes, "\n", static (attr, w) => w.AppendAttribute(attr), append: w => w.AppendLine());

    public static CodeWriter WriteCommentLine(this CodeWriter writer, string comment) =>
        writer.Append("//").AppendLine(comment);

    public static CodeWriter WriteCodeBlock(this CodeWriter writer, Action<CodeWriter> writeBlock) =>
        writer.WriteBlock(Brackets, writeBlock);

    public static CodeWriter WriteCodeBlock<T>(this CodeWriter writer, T arg, Action<T, CodeWriter> writeBlock) =>
        writer.WriteBlock(Brackets, arg, writeBlock);

    public static CodeWriter WriteGenericArgs(this CodeWriter writer, IEnumerable<GenericTypeBuilder> generics) =>
        writer.WriteJoin(generics, ", ",
            writeEntry: static (entry, w) => w.AppendGeneric(entry),
            prepend: static w => w.Append("<"),
            append: static w => w.Append(">")
        );

    public static CodeWriter WriteBaseTypes(this CodeWriter writer, IEnumerable<TypeDescriptor> baseTypes) =>
        writer.WriteJoin(baseTypes, ", ",
            writeEntry: static (entry, w) => w.Append(entry.FullName),
            prepend: static w => w.Append(": ")
        );

    public static CodeWriter WriteConstraints(this CodeWriter writer, IEnumerable<GenericTypeBuilder> generics) =>
        writer.WriteJoin(generics.Where(g => g.AllConstraints.Any()), "\n",
            writeEntry: static (generic, gw) => gw.AppendJoin(", ", generic.AllConstraints),
            prepend: static w => w.Append(" where ")
        );

    public static CodeWriter WriteBlock(this CodeWriter writer, (string open, string close) separators,
        Action<CodeWriter> writeBlock)
    {
        writer.Append(separators.open);

        var blockWriter = writer.EnterBlock();
        writeBlock(blockWriter);

        writer.Append(separators.close);

        return writer;
    }

    public static CodeWriter WriteBlock<T>(this CodeWriter writer, (string open, string close) separators,
        T arg, Action<T, CodeWriter> writeBlock)
    {
        writer.Append(separators.open);

        var blockWriter = writer.EnterBlock();
        writeBlock(arg, blockWriter);

        writer.Append(separators.close);

        return writer;
    }

    public static CodeWriter WriteJoin<T>(this CodeWriter writer,
        IEnumerable<T> enumerable,
        string? separator,
        Action<T, CodeWriter> writeEntry,
        Action<CodeWriter>? prepend = null,
        Action<CodeWriter>? append = null)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer;

        prepend?.Invoke(writer);
        writeEntry(enumerator.Current, writer);
        while (enumerator.MoveNext())
        {
            writer.Append(separator);
            writeEntry(enumerator.Current, writer);
        }

        append?.Invoke(writer);

        return writer;
    }

    public static CodeWriter WriteJoin<T, TArg>(this CodeWriter writer,
        TArg arg,
        IEnumerable<T> enumerable,
        string? separator,
        Action<TArg, T, CodeWriter> writeEntry,
        Action<TArg, CodeWriter>? prepend = null,
        Action<TArg, CodeWriter>? append = null)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer;

        prepend?.Invoke(arg, writer);
        writeEntry(arg, enumerator.Current, writer);
        while (enumerator.MoveNext())
        {
            writer.Append(separator);
            writeEntry(arg, enumerator.Current, writer);
        }

        append?.Invoke(arg, writer);

        return writer;
    }

    private static string GetTypeKind(ITypeBuilder builder) =>
        builder switch
        {
            EnumBuilder => "enum",
            ClassBuilder => "class",
            InterfaceBuilder => "interface",
            StructBuilder { IsMutable: true } => "struct",
            StructBuilder { IsMutable: false } => "readonly struct",
            _ => throw new ArgumentOutOfRangeException(nameof(builder))
        };
}