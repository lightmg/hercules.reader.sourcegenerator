using System;
using System.Collections.Generic;
using System.Linq;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Declarations;
using Vostok.Hercules.Serializer.Generator.Core.Primitives;
using Vostok.Hercules.Serializer.Generator.Extensions;

namespace Vostok.Hercules.Serializer.Generator.Core.Writer.Extensions;

public static class CodeWriterWriteExtensions
{
    private static (string, string) Brackets => ("{", "}");
    private static (string, string) Parentheses => ("(", ")");

    public static CodeWriter WriteMethods(this CodeWriter writer, IEnumerable<MethodBuilder> methods)
    {
        var orderedMethods = methods
            .OrderByDescending(m => m.Accessibility)
            .ThenBy(m => m.IsStatic ? 0 : 1)
            .ThenBy(m => m.Name);

        foreach (var method in orderedMethods)
            writer.WriteMethod(method).AppendLine().AppendLine();

        return writer;
    }

    public static CodeWriter WriteMethod(this CodeWriter writer, MethodBuilder method) =>
        writer
            .AppendAccessibility(method.Accessibility).Append(" ")
            .When(method.IsStatic, static w => w.Append("static "))
            .AppendType(method.ReturnType ?? ReferencedType.Void).Append(" ")
            .Append(method.Name)
            .WriteGenericArgs(method.Generics)
            .WriteParameters(method.Parameters)
            .WhenNotNull(method.EmitBody,
                then: (emitBody, w) => w.WriteCodeBlock(emitBody),
                @else: w => w.Append(";")
            );
    /* TODO .AppendGenericConstratins(builder.Generics) */

    public static CodeWriter WriteParameters(this CodeWriter writer, IEnumerable<ParameterBuilder> parameters) =>
        writer.WriteJoinBlock(Parentheses, ",\n", parameters, static (current, cw) => cw
            .AppendParameter(current)
        );

    public static CodeWriter WriteProperties(this CodeWriter writer, IEnumerable<PropertyBuilder> properties)
    {
        foreach (var property in properties)
            writer.WriteProperty(property).AppendLine();
        return writer;
    }

    public static CodeWriter WriteConstructor(this CodeWriter writer, ConstructorBuilder ctorBuilder) =>
        writer
            .AppendAccessibility(ctorBuilder.Accessibility).Append(" ")
            .AppendType(ctorBuilder.DeclaringTypeName)
            .WriteParameters(ctorBuilder.Parameters)
            .WhenNotNull(ctorBuilder.EmitBody, (emit, w) => w.WriteCodeBlock(emit));

    public static CodeWriter WriteProperty(this CodeWriter writer, PropertyBuilder property) =>
        writer
            .AppendAccessibility(property.Accessibility).Append(" ")
            .When(property is { Kind: ParameterKind.Field, ReadOnly: true }, w => w.Append("readonly "))
            .AppendType(property.Type).Append(" ")
            .Append(property.Name)
            .When(property is { Kind: ParameterKind.Property, ReadOnly: true }, w => w.Append(" { get; }"))
            .When(property is { Kind: ParameterKind.Property, ReadOnly: false }, w => w.Append(" { get; set; }"))
            .When(property.Kind == ParameterKind.Field, w => w.Append(";"));

    public static CodeWriter WriteType(this CodeWriter writer, TypeBuilder typeBuilder) =>
        writer
            .WriteCommentLine("<auto-generated>")
            .WriteNamespace(typeBuilder.Namespace, nw => nw
                .WriteAttributes(typeBuilder.Attributes)
                .AppendAccessibility(typeBuilder.Accessibility).Append(" ")
                .AppendKind(typeBuilder.Kind).Append(" ")
                .Append(typeBuilder.Name)
                .WriteGenericArgs(typeBuilder.Generics).Append(" ")
                .WriteBaseTypes(typeBuilder.Interfaces.PrependIfNotNull(typeBuilder.BaseType))
                .AppendLine()
                .WriteCodeBlock(tw => tw
                    .WriteProperties(typeBuilder.Properties.Where(p => p.Kind == ParameterKind.Field))
                    .AppendLine()
                    .WriteJoin(typeBuilder.Constructors, "\n\n", (ctor, cw) => cw.WriteConstructor(ctor))
                    .AppendLine()
                    .WriteProperties(typeBuilder.Properties.Where(p => p.Kind == ParameterKind.Property))
                    .AppendLine()
                    .WriteMethods(typeBuilder.Methods)
                )
            );

    public static CodeWriter WriteNamespace(this CodeWriter writer, string ns, Action<CodeWriter> writeContent) =>
        writer
            .AppendNamespace(ns)
            .AppendLine()
            .WriteCodeBlock(writeContent);

    public static CodeWriter WriteAttributes(this CodeWriter writer, IEnumerable<string> attributes) =>
        writer.WriteJoin(attributes, "\n", (attr, w) => w.AppendAttribute(attr));

    public static CodeWriter WriteCommentLine(this CodeWriter writer, string comment) =>
        writer.Append("//").AppendLine(comment);

    public static CodeWriter WriteCodeBlock(this CodeWriter writer, Action<CodeWriter> writeBlock) =>
        writer.WriteBlock(Brackets, writeBlock);

    public static CodeWriter WriteGenericArgs(this CodeWriter writer, IEnumerable<GenericTypeBuilder> generics) =>
        writer.WriteJoin(generics.Select(g => g.Name), ", ",
            (entry, w) => w.Append(entry),
            prepend: w => w.Append("<"),
            append: w => w.Append(">")
        );

    public static CodeWriter WriteBaseTypes(this CodeWriter writer, IEnumerable<ReferencedType> baseTypes) =>
        writer.WriteJoin(baseTypes, ", ",
            (entry, w) => w.Append(entry.FullName),
            prepend: w => w.Append(": ")
        );

    private static CodeWriter WriteBlock(this CodeWriter writer, (string open, string close) separators,
        Action<CodeWriter> writeBlock)
    {
        writer.AppendLine(separators.open);

        var blockWriter = writer.EnterBlock();
        writeBlock(blockWriter);

        writer.AppendLine(separators.close);

        return writer;
    }

    private static CodeWriter WriteJoinBlock<T>(this CodeWriter writer, (string? open, string? close) separators,
        string? separator, IEnumerable<T> enumerable,
        Action<T, CodeWriter> writeEntry)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer
                .AppendIfNotNull(separators.open)
                .AppendIfNotNull(separators.close)
                .AppendLine();

        if (separators.open != null)
            writer.AppendLine(separators.open);

        var blockWriter = writer.EnterBlock();

        writeEntry(enumerator.Current, blockWriter);
        while (enumerator.MoveNext())
        {
            blockWriter.Append(separator);
            writeEntry(enumerator.Current, blockWriter);
        }

        writer.AppendLine();
        if (separators.close != null)
            writer.AppendLine(separators.close);

        return writer;
    }

    public static CodeWriter WriteJoin<T>(this CodeWriter writer,
        IEnumerable<T> enumerable,
        string? separator,
        Action<T, CodeWriter> writeEntry,
        Action<CodeWriter>? prepend = null,
        Action<CodeWriter>? append = null)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer;

        prepend?.Invoke(writer);
        writeEntry(enumerator.Current, writer);
        while (enumerator.MoveNext())
        {
            writer.Append(separator);
            writeEntry(enumerator.Current, writer);
        }

        append?.Invoke(writer);

        return writer;
    }

    public static CodeWriter WriteJoinDecorated<T>(this CodeWriter writer,
        IEnumerable<T> enumerable,
        string? separator,
        Action<T, CodeWriter> writeEntry,
        Action<CodeWriter>? prepend = null,
        Action<CodeWriter>? append = null)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer;

        writeEntry(enumerator.Current, writer);
        while (enumerator.MoveNext())
        {
            writer.Append(separator);
            writeEntry(enumerator.Current, writer);
        }

        return writer;
    }
}