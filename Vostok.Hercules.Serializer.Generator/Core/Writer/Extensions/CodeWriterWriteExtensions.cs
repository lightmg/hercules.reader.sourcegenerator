using System;
using System.Collections.Generic;
using System.Linq;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Declarations;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Members;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Types;
using Vostok.Hercules.Serializer.Generator.Core.Builders.Types.Abstract;
using Vostok.Hercules.Serializer.Generator.Core.Primitives;
using Vostok.Hercules.Serializer.Generator.Extensions;

namespace Vostok.Hercules.Serializer.Generator.Core.Writer.Extensions;

public static class CodeWriterWriteExtensions
{
    private static (string, string) Brackets => ("{", "}");
    private static (string, string) Parentheses => ("(", ")");

    public static CodeWriter WriteMethods(this CodeWriter writer, IEnumerable<MethodBuilder> methods)
    {
        var orderedMethods = methods
            .OrderByDescending(m => m.Accessibility)
            .ThenBy(m => m.IsStatic ? 0 : 1)
            .ThenBy(m => m.Name);

        foreach (var method in orderedMethods)
            writer.WriteMethod(method).AppendLine().AppendLine();

        return writer;
    }

    public static CodeWriter WriteMethod(this CodeWriter writer, MethodBuilder method) =>
        writer
            .AppendAccessibility(method.Accessibility).Append(" ")
            .When(method.IsStatic, static w => w.Append("static "))
            .When(method.IsOverride, static w => w.Append("override "))
            .AppendType(method.ReturnType ?? ReferencedType.Void).Append(" ")
            .Append(method.Name)
            .WriteGenericArgs(method.Generics)
            .WriteParameters(method.Parameters)
            .WriteConstraints(method.Generics)
            .WhenNotNull(method.EmitBody,
                then: (emitBody, w) => w.WriteCodeBlock(emitBody),
                @else: w => w.Append(";")
            );

    public static CodeWriter WriteParameters(this CodeWriter writer, IEnumerable<ParameterBuilder> parameters) =>
        writer.WriteJoinBlock(Parentheses, ",\n", parameters, static (current, cw) => cw
            .AppendParameter(current)
        );

    public static CodeWriter WriteProperties(this CodeWriter writer, IEnumerable<PropertyBuilder> properties)
    {
        foreach (var property in properties)
            writer.WriteProperty(property).AppendLine();
        return writer;
    }

    public static CodeWriter WriteConstructor(this CodeWriter writer, ConstructorBuilder ctorBuilder) =>
        writer
            .AppendAccessibility(ctorBuilder.Accessibility).Append(" ")
            .AppendType(ctorBuilder.DeclaringTypeName)
            .WriteParameters(ctorBuilder.Parameters)
            .WriteJoin(ctorBuilder.BaseCtorArgs, ", ",
                writeEntry: (arg, w) => w.Append(arg.Key).Append(": ").Append(arg.Value),
                prepend: w => w.Append(" : base("),
                append: w => w.AppendLine(")")
            )
            .WhenNotNull(ctorBuilder.EmitBody, (emit, w) => w.WriteCodeBlock(emit));

    public static CodeWriter WriteProperty(this CodeWriter writer, PropertyBuilder property) =>
        writer
            .AppendAccessibility(property.Accessibility).Append(" ")
            .When(property is { Kind: ParameterKind.Field, ReadOnly: true }, w => w.Append("readonly "))
            .AppendType(property.Type).Append(" ")
            .Append(property.Name)
            .When(property is { Kind: ParameterKind.Property, ReadOnly: true }, w => w.Append(" { get; }"))
            .When(property is { Kind: ParameterKind.Property, ReadOnly: false }, w => w.Append(" { get; set; }"))
            .When(property.Kind == ParameterKind.Field, w => w.Append(";"));

    public static CodeWriter WriteType(this CodeWriter writer, ITypeBuilder builder) =>
        writer
            .WriteCommentLine("<auto-generated>")
            .WriteNamespace(builder.Namespace, nw => nw
                .WriteAttributes(builder.Attributes)
                .AppendAccessibility(builder.Accessibility).Append(" ")
                .Append(GetTypeKind(builder)).Append(" ")
                .Append(builder.Name)
                .WhenOfType<StatefulTypeBuilder>(builder, (s, w) => w
                    .WriteGenericArgs(s.Generics).Append(" ")
                    .WriteBaseTypes(s.Interfaces.PrependIfNotNull(s is ClassBuilder cb ? cb.BaseType : null))
                    .WriteConstraints(s.Generics)
                    .AppendLine()
                    .WriteCodeBlock(tw => tw
                        .WriteProperties(s.Properties.Where(p => p.Kind == ParameterKind.Field))
                        .AppendLine()
                        .WhenOfType<IInitializabeTypeBuilder>(s, (i, iw) => iw
                            .WriteJoin(i.Constructors, "\n\n", (ctor, cw) => cw.WriteConstructor(ctor)
                            )
                            .AppendLine()
                            .WriteProperties(s.Properties.Where(p => p.Kind == ParameterKind.Property))
                            .AppendLine()
                            .WriteMethods(s.Methods)
                        )
                    )
                )
            );

    public static CodeWriter WriteNamespace(this CodeWriter writer, string ns, Action<CodeWriter> writeContent) =>
        writer
            .AppendNamespace(ns)
            .AppendLine()
            .WriteCodeBlock(writeContent);

    public static CodeWriter WriteAttributes(this CodeWriter writer, IEnumerable<string> attributes) =>
        writer
            .WriteJoin(attributes, "\n", (attr, w) => w.AppendAttribute(attr), append: w => w.AppendLine());

    public static CodeWriter WriteCommentLine(this CodeWriter writer, string comment) =>
        writer.Append("//").AppendLine(comment);

    public static CodeWriter WriteCodeBlock(this CodeWriter writer, Action<CodeWriter> writeBlock) =>
        writer.WriteBlock(Brackets, writeBlock);

    public static CodeWriter WriteGenericArgs(this CodeWriter writer, IEnumerable<GenericTypeBuilder> generics) =>
        writer.WriteJoin(generics.Select(g => g.Name), ", ",
            (entry, w) => w.Append(entry),
            prepend: w => w.Append("<"),
            append: w => w.Append(">")
        );

    public static CodeWriter WriteBaseTypes(this CodeWriter writer, IEnumerable<ReferencedType> baseTypes) =>
        writer.WriteJoin(baseTypes, ", ",
            (entry, w) => w.Append(entry.FullName),
            prepend: w => w.Append(": ")
        );

    public static CodeWriter WriteConstraints(this CodeWriter writer, IEnumerable<GenericTypeBuilder> generics) =>
        writer.WriteJoin(generics.Where(g => g.AllConstraints.Any()), "\n",
            (generic, gw) => gw.AppendJoin(", ", generic.AllConstraints),
            prepend: w => w.Append(" where ")
        );

    private static CodeWriter WriteBlock(this CodeWriter writer, (string open, string close) separators,
        Action<CodeWriter> writeBlock)
    {
        writer.AppendLine(separators.open);

        var blockWriter = writer.EnterBlock();
        writeBlock(blockWriter);

        writer.AppendLine(separators.close);

        return writer;
    }

    private static CodeWriter WriteJoinBlock<T>(this CodeWriter writer, (string? open, string? close) separators,
        string? separator, IEnumerable<T> enumerable,
        Action<T, CodeWriter> writeEntry)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer
                .AppendIfNotNull(separators.open)
                .AppendIfNotNull(separators.close)
                .AppendLine();

        if (separators.open != null)
            writer.AppendLine(separators.open);

        var blockWriter = writer.EnterBlock();

        writeEntry(enumerator.Current, blockWriter);
        while (enumerator.MoveNext())
        {
            blockWriter.Append(separator);
            writeEntry(enumerator.Current, blockWriter);
        }

        writer.AppendLine();
        if (separators.close != null)
            writer.AppendLine(separators.close);

        return writer;
    }

    public static CodeWriter WriteJoin<T>(this CodeWriter writer,
        IEnumerable<T> enumerable,
        string? separator,
        Action<T, CodeWriter> writeEntry,
        Action<CodeWriter>? prepend = null,
        Action<CodeWriter>? append = null)
    {
        separator ??= string.Empty;
        using var enumerator = enumerable.GetEnumerator();
        if (!enumerator.MoveNext())
            return writer;

        prepend?.Invoke(writer);
        writeEntry(enumerator.Current, writer);
        while (enumerator.MoveNext())
        {
            writer.Append(separator);
            writeEntry(enumerator.Current, writer);
        }

        append?.Invoke(writer);

        return writer;
    }

    private static string GetTypeKind(ITypeBuilder builder) =>
        builder switch
        {
            ClassBuilder => "class",
            InterfaceBuilder => "interface",
            StructBuilder { IsMutable: true } => "struct",
            StructBuilder { IsMutable: false } => "readonly struct",
            _ => throw new ArgumentOutOfRangeException(nameof(builder))
        };
}